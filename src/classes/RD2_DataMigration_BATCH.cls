/*
    Copyright (c) 2019 Salesforce.org
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Salesforce.org nor the names of
      its contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.
*/
/**
* @author Salesforce.org
* @date 2019
* @group Recurring Donations
* @description Data Migration batch job used to convert Recurring Donation Records from
* Legacy to Enhanced Recurring Donation format
*
*/
public class RD2_DataMigration_BATCH implements Database.Batchable<SObject>, Schedulable, Database.Stateful {

    public static final String LOG_CONTEXT_PREFIX = 'RDDataMigration:';
    public static final String LOG_EXCEPTION_ERROR_TYPE = 'Data Migration Exception';

    /**
    * @description Contains Recurring Donation custom settings
    */
    private npe03__Recurring_Donations_Settings__c rdSettings = UTIL_CustomSettingsFacade.getRecurringDonationsSettings();

    /**
    * @description The default batch size for the migration job if it's not specified
    * in custom settings
    */
    private static final Integer DEFAULT_MIGRATION_JOB_BATCH_SIZE = 25;

    /**
    * @description Indicates if Recurring Donations will be attempted to be converted but not committed to database
    */
    private Boolean isDryRunMode = false;

    /**
    * @description Batch size for Apex Job. Uses default if the Custom Setting batch size is not provided.
    */
    public Integer batchSize {
        get {
            if (batchSize == null) {
                Decimal configValue = UTIL_CustomSettingsFacade.getRecurringDonationsSettings().DataMigrationBatchSize__c;

                if (configValue == null) {
                    configValue = DEFAULT_MIGRATION_JOB_BATCH_SIZE;
                }

                batchSize = configValue.intValue();
            }
            return batchSize;
        }
        private set;
    }

    /**
    * @description Contains batch job Id
    */
    private Id batchJobId;

    /**
    * @description Constructs context used to log errors
    */
    private String logContext {
        get {
            if (logContext == null) {
                logContext = constructLogContext();
            }
            return logContext;
        }
        set;
    }

    /***
    * @description Schedulable executes the batch job
    */
    public void execute(SchedulableContext context) {
        Database.executeBatch(new RD2_DataMigration_BATCH(), batchSize);
    }

    /**
    * @description Enables Dry Run Mode for the migration job
    */
    public RD2_DataMigration_BATCH enableDryRunMode() {
        isDryRunMode = true;
        return this;
    }

    /**
    * @description Batch Start Method
    */
    public Database.QueryLocator start(Database.BatchableContext context) {
        setBatchJobId(context);

        if (!RD2_EnablementService.isRecurringDonations2Enabled) {
            throw new MigrationException(System.Label.RD2_ErrorDataMigrationJobCannotBeRun);

        } else if (rdSettings.npe03__Open_Opportunity_Behavior__c == RD2_Constants.CloseActions.No_Action.name()) {
            throw new MigrationException(System.Label.RD2_DataMigrationInvalidCloseAction);
            
        } else {
            return Database.getQueryLocator(getRDMigrationQuery());
        }
    }

    /**
    * @description Converts legacy Recurring Donation into enhanced Recurring Donation format
    * @param context Batchable context
    * @param rds Recurring Donations
    * @return void
    */
    public void execute(Database.BatchableContext context, List<npe03__Recurring_Donation__c> rds) {
        setBatchJobId(context);
        
        RD2_OpportunityEvaluationService.overrideVoidOfOpenOpps = true;

        Logger logger = new Logger(logContext, LOG_EXCEPTION_ERROR_TYPE);
        Map<Id, List<Opportunity>> oppsByRdId = getRelatedOpportunities(rds);
        Map<Id, List<Opportunity>> openOppsToVoidByRDId = new Map<Id, List<Opportunity>>();
        List<npe03__Recurring_Donation__c> convertedRDs = new List<npe03__Recurring_Donation__c>();

        for (npe03__Recurring_Donation__c rd : rds) {
            RD2_DataMigrationMapper mapper = new RD2_DataMigrationMapper(rd)
                .withRelatedOpportunities(oppsByRdId.get(rd.Id));

            if (mapper.isConverted()) {
                continue;
            }

            try {
                convertedRDs.add(mapper.convertToEnhancedRD());

            } catch (Exception e) {
                logger.addError(e, rd.Id);
                continue;
            }

            if (!mapper.openOppsToVoid.isEmpty()) {
                openOppsToVoidByRDId.put(rd.Id, mapper.openOppsToVoid);
            }
        }

        handleSaveAndLogging(convertedRDs, openOppsToVoidByRDId, logger);
    }

    /**
    * @description Batch Finish Method
    */
    public void finish(Database.BatchableContext context) {
    }


    /**
    * @description Sets batch job Id
    * @param context Batchable context
    * @return void
    */
    private void setBatchJobId(Database.BatchableContext context) {
        if (context == null || batchJobId != null) {
            return;
        }

        batchJobId = context.getJobId();
    }

    /**
    * @description Constructs log context
    * @return String Log context containing batch job Created Date
    */
    private String constructLogContext() {
        UTIL_BatchJobService.BatchJob batchJob = new UTIL_BatchJobService().getBatchJob(batchJobId);

        String formattedDateSuffix = batchJob == null
            ? ''
            : ' ' + String.valueOf(batchJob.CreatedDate);

        return LOG_CONTEXT_PREFIX + formattedDateSuffix;
    }

    /**
    * @description Save records and log all exceptions and errors generated during records' validation and save
    * @param convertedRDs Converted Recurring Donations
    * @param openOppsToVoidByRDId Open Opportunities by Recurring Donation Id to void
    * @param logger Exception/error log container
    * @return void
    */
    @TestVisible
    private void handleSaveAndLogging(
        List<npe03__Recurring_Donation__c> convertedRDs, 
        Map<Id, List<Opportunity>> openOppsToVoidByRDId,
        Logger logger
    ) {
        Savepoint sp = Database.setSavepoint();

        Set<Id> savedRDIds = saveRecurringDonations(convertedRDs, logger);

        voidOpenOpportunities(savedRDIds, openOppsToVoidByRDId, logger);

        if (this.isDryRunMode || logger.hasRelatedRecordFailed) {
            Database.rollback(sp);
        }

        logger.processErrors();
    }

    /**
    * @description Save Recurring Donations
    * @param convertedRDs Converted Recurring Donations
    * @param logger Exception/error log container
    * @return Set<Id> Successfully saved Recurring Donation Ids
    */
    private Set<Id> saveRecurringDonations(List<npe03__Recurring_Donation__c> convertedRDs,  Logger logger) {

        List<Database.SaveResult> saveResults = convertedRDs.isEmpty()
            ? new List<Database.SaveResult>()
            : Database.update(convertedRDs, false);
        
        logger.addErrors(saveResults, convertedRDs);

        return getSavedRecordIds(saveResults);
    }

    /**
    * @description Returns Ids of records that were saved successfully
    * @param saveResults Insert/update DML save results
    * @return Set<Id>
    */
    private Set<Id> getSavedRecordIds(List<Database.SaveResult> saveResults) {
        Set<Id> recordIds = new Set<Id>();

        for (Database.SaveResult result : saveResults) {
            if (result.isSuccess()) {
                recordIds.add(result.getId());
            }
        }

        return recordIds;
    }

    /**
    * @description Handles Open Opportunities that should be voided (sets them to Closed Lost or deletes them)
    * @param savedRDIds Ids of successfully saved Recurring Donations
    * @param openOppsToVoidByRDId To be voided Open Opportunities by Recurring Donation Id
    * @param logger Exception/error log container
    * @return void
    */
    private void voidOpenOpportunities(Set<Id> savedRDIds, Map<Id, List<Opportunity>> openOppsToVoidByRDId, Logger logger) {
        List<Opportunity> opps = new List<Opportunity>();
        for (Id rdId : savedRDIds) {
            if (openOppsToVoidByRDId.containsKey(rdId)) {
                opps.addAll(openOppsToVoidByRDId.get(rdId));
            }
        }

        if (opps.isEmpty()) {
            return;
        }

        List<Object> dmlResults = new List<Object>();
        if (rdSettings.npe03__Open_Opportunity_Behavior__c == RD2_Constants.CloseActions.Delete_Open_Opportunities.name()) {
            dmlResults = Database.delete(opps, false);

        } else if (rdSettings.npe03__Open_Opportunity_Behavior__c == RD2_Constants.CloseActions.Mark_Opportunities_Closed_Lost.name()) {
            for (Opportunity opp : opps) {
                opp.StageName = System.Label.npe03.RecurringDonationClosedLostOpportunityStage;
            } 

            dmlResults = Database.update(opps, false);
        }

        logger.addErrors(dmlResults, opps);
    }

    /**
    * @description Build the query of all standard RD fields to use for the batch query
    * @return SOQL
    */
    @TestVisible
    private String getRDMigrationQuery() {
        Set<String> rdFields = new Set<String>{
            'Id',
            'Name',
            'npe03__Open_Ended_Status__c',
            'npe03__Next_Payment_Date__c',
            'npe03__Paid_Amount__c',
            'npe03__Organization__c',
            'npe03__Contact__c',
            'npe03__Installment_Amount__c',
            'npe03__Installments__c',
            'npe03__Amount__c',
            'npe03__Total__c',
            'npe03__Installment_Period__c',
            'npe03__Date_Established__c',
            'npe03__Schedule_Type__c',
            'npe03__Recurring_Donation_Campaign__c',
            'npe03__Total_Paid_Installments__c',
            'Ownerid',
            'Always_Use_Last_Day_of_Month__c',
            'Day_of_Month__c',
            'StartDate__c',
            'InstallmentFrequency__c',
            'PaymentMethod__c',
            'Status__c',
            'RecurringType__c'
        };
        if (UserInfo.isMultiCurrencyOrganization()) {
            rdFields.add('CurrencyIsoCode');
        }

        return new UTIL_Query()
            .withFrom(npe03__Recurring_Donation__c.SObjectType)
            .withSelectFields(rdFields)
            .withOrderBy('npe03__Last_Payment_Date__c')
            .build();
    }

    /**
    * @description Build a map of related Opportunities for each recurring donation
    * @param rds Collection of Recurring Donations to retrieve related Opps for
    * @return Map<Id, List<Opportunity>>
    */
    private Map<Id, List<Opportunity>> getRelatedOpportunities(List<npe03__Recurring_Donation__c> rds) {
        Map<Id, List<Opportunity>> oppsByRdId = new Map<Id, List<Opportunity>>();

        for (Opportunity opp : [
            SELECT Id,
                Name,
                Amount,
                CloseDate,
                CreatedDate,
                IsWon,
                IsClosed,
                npe03__Recurring_Donation__c
            FROM Opportunity
            WHERE npe03__Recurring_Donation__c IN :rds
            ORDER BY npe03__Recurring_Donation__c, CloseDate ASC
        ]) {

            if (!oppsByRdId.containsKey(opp.npe03__Recurring_Donation__c)) {
                oppsByRdId.put(opp.npe03__Recurring_Donation__c, new List<Opportunity>());
            }
            oppsByRdId.get(opp.npe03__Recurring_Donation__c).add(opp);
        }

        return oppsByRdId;
    }


    /**
    * @description Builds and creates logs for errors and exceptions.
    * The current logger version is the ERR_Handler wrapper.
    */
    public class Logger {
        /**
        * @description Contains error results
        */
        @TestVisible
        private ERR_Handler.Errors errorResult = new ERR_Handler.Errors();

        /**
        * @description Context in which logs are created and can be filtered out
        */
        private String context;

        /**
        * @description Exception error type
        */
        private String exceptionErrorType;

        /**
        * @description Indicates if there is error on a related record DML operation
        */
        public Boolean hasRelatedRecordFailed { get; private set; }

        /**
        * @description Constructor
        * @param context Log context
        */
        public Logger(String context, String exceptionErrorType) {
            this.context = context;
            this.exceptionErrorType = exceptionErrorType;
            hasRelatedRecordFailed = false;
        }

        /**
        * @description Constructs log record and adds it into the error log container
        * @param e Exception
        * @param rdId Recurring Donation Id
        * @return void
        */
        public void addError(Exception e, Id rdId) {
            Error__c logEntry = new Error__c(
                Context_Type__c = context,
                Datetime__c = System.now(),
                Related_Record_ID__c = rdId,
                Record_URL__c = ERR_Handler.getRecordURL(rdId),
                Error_Type__c = exceptionErrorType,
                Full_Message__c = e.getMessage()
            );

            errorResult.errorRecords.add(logEntry);
        }

        /**
        * @description Constructs and collects error logs for records that failed in the DML operation
        * @param dmlResults Insert/update/delete DML operation results
        * @param records Records which were saved/deleted by the DML operation
        * @return void
        */
        public void addErrors(List<Object> dmlResults, List<SObject> records) {
            if (records.isEmpty()) {
                return;
            }
            
            ERR_Handler.Errors dmlErrors = ERR_Handler.getErrorsOnly(dmlResults, records);

            if (dmlErrors.errorsExist && records[0].getSObjectType() != npe03__Recurring_Donation__c.SObjectType) {
                hasRelatedRecordFailed = true;
            }

            errorResult.errorRecords.addAll(
                dmlErrors.errorRecords
            );
        }

        /**
        * @description Constructs and collects error logs for records that failed in the DML operation
        * @param dmlResults Insert/update/delete DML operation results
        * @param records Records which were saved/deleted by the DML operation
        * @return void
        */
        public void processErrors() {
            errorResult.errorsExist = !errorResult.errorRecords.isEmpty();

            ERR_Handler.processErrorsOnly(errorResult, context);
        }
    }


    /**
    * @description Custom data migration exception
    */
    private class MigrationException extends Exception { }
}